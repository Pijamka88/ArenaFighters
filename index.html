<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Car Chase</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: manipulation;
        }
        
        #game-container {
            position: relative;
            width: 300px;
            height: 300px;
            background-color: #333;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        #game-board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .road {
            stroke: #555;
            stroke-width: 10;
            fill: none;
        }
        
        .intersection {
            fill: #444;
        }
        
        .traffic-light {
            stroke: #000;
            stroke-width: 1;
        }
        
        .traffic-red {
            fill: #f00;
        }
        
        .traffic-green {
            fill: #0f0;
        }
        
        .car {
            position: absolute;
            width: 12px;
            height: 20px;
            border-radius: 3px;
            transform-origin: center;
            transition: transform 0.3s ease, left 0.3s ease, top 0.3s ease;
        }
        
        #player-car {
            background-color: #00f;
            z-index: 10;
        }
        
        .police-car {
            background-color: #f00;
            z-index: 9;
        }
        
        #ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 300px;
        }
        
        #stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
        }
        
        #dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #dice {
            width: 50px;
            height: 50px;
            background-color: #fff;
            border: 2px solid #000;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        #direction-buttons {
            display: none;
            justify-content: space-between;
            width: 100%;
            margin-top: 10px;
        }
        
        .direction-btn {
            padding: 10px;
            width: 30%;
        }
        
        #message {
            margin-top: 10px;
            color: #f00;
            font-weight: bold;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <svg id="game-board"></svg>
        <div id="player-car" class="car"></div>
        <div id="police-car1" class="car police-car"></div>
        <div id="police-car2" class="car police-car"></div>
    </div>
    
    <div id="ui">
        <div id="stats">
            <div>Turns: <span id="turn-counter">0</span></div>
            <div>Police Distance: <span id="police-distance">-</span></div>
        </div>
        
        <div id="dice-container">
            <div id="dice">?</div>
            <button id="roll-btn">Roll Dice</button>
        </div>
        
        <div id="direction-buttons">
            <button id="left-btn" class="direction-btn">← Left</button>
            <button id="straight-btn" class="direction-btn">↑ Straight</button>
            <button id="right-btn" class="direction-btn">→ Right</button>
        </div>
        
        <div id="message"></div>
    </div>

    <script>
        // Game configuration
        const config = {
            gridSize: 7, // 7x7 grid of intersections
            cellSize: 40, // pixels between intersections
            roadWidth: 10,
            initialPoliceDistance: 3, // how far police start from player
            maxTurns: 50, // game ends after this many turns
            policeCatchDistance: 0.5 // distance at which police catch player
        };
        
        // Game state
        let state = {
            turn: 0,
            playerPosition: { x: Math.floor(config.gridSize / 2), y: Math.floor(config.gridSize / 2) },
            playerDirection: 0, // 0: right, 1: down, 2: left, 3: up
            policePositions: [],
            policeDirections: [],
            diceValue: 0,
            movesRemaining: 0,
            currentPath: [],
            gameOver: false,
            trafficLights: {} // key: "x,y,direction", value: "red" or "green"
        };
        
        // DOM elements
        const gameBoard = document.getElementById('game-board');
        const playerCar = document.getElementById('player-car');
        const policeCar1 = document.getElementById('police-car1');
        const policeCar2 = document.getElementById('police-car2');
        const turnCounter = document.getElementById('turn-counter');
        const policeDistance = document.getElementById('police-distance');
        const diceElement = document.getElementById('dice');
        const rollBtn = document.getElementById('roll-btn');
        const leftBtn = document.getElementById('left-btn');
        const straightBtn = document.getElementById('straight-btn');
        const rightBtn = document.getElementById('right-btn');
        const directionButtons = document.getElementById('direction-buttons');
        const messageElement = document.getElementById('message');
        
        // Initialize the game
        function initGame() {
            // Clear the board
            gameBoard.innerHTML = '';
            
            // Create roads and intersections
            drawCity();
            
            // Initialize traffic lights (50% chance red or green for each direction at each intersection)
            initializeTrafficLights();
            
            // Position player at center
            updatePlayerPosition();
            
            // Position police cars at random distant intersections
            placePoliceCars();
            
            // Update UI
            updateUI();
            
            // Set up event listeners
            rollBtn.addEventListener('click', rollDice);
            leftBtn.addEventListener('click', () => chooseDirection(-1));
            straightBtn.addEventListener('click', () => chooseDirection(0));
            rightBtn.addEventListener('click', () => chooseDirection(1));
        }
        
        // Draw the city grid with roads and intersections
        function drawCity() {
            const centerOffset = (config.gridSize % 2 === 0) ? config.cellSize / 2 : 0;
            
            // Draw roads
            for (let x = 0; x < config.gridSize; x++) {
                for (let y = 0; y < config.gridSize; y++) {
                    const px = x * config.cellSize + centerOffset;
                    const py = y * config.cellSize + centerOffset;
                    
                    // Draw intersection
                    const intersection = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    intersection.setAttribute("x", px - config.roadWidth/2);
                    intersection.setAttribute("y", py - config.roadWidth/2);
                    intersection.setAttribute("width", config.roadWidth);
                    intersection.setAttribute("height", config.roadWidth);
                    intersection.setAttribute("class", "intersection");
                    gameBoard.appendChild(intersection);
                    
                    // Draw roads to adjacent intersections (if they exist)
                    if (x > 0) {
                        // Horizontal road to left
                        const roadH = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        roadH.setAttribute("x1", (x-1) * config.cellSize + centerOffset);
                        roadH.setAttribute("y1", py);
                        roadH.setAttribute("x2", px);
                        roadH.setAttribute("y2", py);
                        roadH.setAttribute("class", "road");
                        gameBoard.appendChild(roadH);
                    }
                    
                    if (y > 0) {
                        // Vertical road up
                        const roadV = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        roadV.setAttribute("x1", px);
                        roadV.setAttribute("y1", (y-1) * config.cellSize + centerOffset);
                        roadV.setAttribute("x2", px);
                        roadV.setAttribute("y2", py);
                        roadV.setAttribute("class", "road");
                        gameBoard.appendChild(roadV);
                    }
                    
                    // Diagonal roads (if they exist)
                    if (x > 0 && y > 0) {
                        // Diagonal road to top-left
                        const roadDL = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        roadDL.setAttribute("x1", (x-1) * config.cellSize + centerOffset);
                        roadDL.setAttribute("y1", (y-1) * config.cellSize + centerOffset);
                        roadDL.setAttribute("x2", px);
                        roadDL.setAttribute("y2", py);
                        roadDL.setAttribute("class", "road");
                        gameBoard.appendChild(roadDL);
                    }
                    
                    if (x < config.gridSize - 1 && y > 0) {
                        // Diagonal road to top-right
                        const roadDR = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        roadDR.setAttribute("x1", (x+1) * config.cellSize + centerOffset);
                        roadDR.setAttribute("y1", (y-1) * config.cellSize + centerOffset);
                        roadDR.setAttribute("x2", px);
                        roadDR.setAttribute("y2", py);
                        roadDR.setAttribute("class", "road");
                        gameBoard.appendChild(roadDR);
                    }
                }
            }
        }
        
        // Initialize traffic lights at intersections
        function initializeTrafficLights() {
            state.trafficLights = {};
            
            for (let x = 0; x < config.gridSize; x++) {
                for (let y = 0; y < config.gridSize; y++) {
                    // For each direction at this intersection
                    for (let dir = 0; dir < 8; dir++) {
                        const lightState = Math.random() < 0.5 ? 'red' : 'green';
                        state.trafficLights[`${x},${y},${dir}`] = lightState;
                    }
                }
            }
        }
        
        // Place police cars at random distant intersections
        function placePoliceCars() {
            state.policePositions = [];
            state.policeDirections = [];
            
            // Get all positions at least initialPoliceDistance away from player
            const possiblePositions = [];
            for (let x = 0; x < config.gridSize; x++) {
                for (let y = 0; y < config.gridSize; y++) {
                    const dx = Math.abs(x - state.playerPosition.x);
                    const dy = Math.abs(y - state.playerPosition.y);
                    const distance = Math.max(dx, dy);
                    if (distance >= config.initialPoliceDistance) {
                        possiblePositions.push({ x, y });
                    }
                }
            }
            
            // Shuffle and pick 2 positions
            shuffleArray(possiblePositions);
            const police1 = possiblePositions[0];
            const police2 = possiblePositions[1];
            
            state.policePositions.push({ ...police1 });
            state.policePositions.push({ ...police2 });
            
            // Random directions
            state.policeDirections.push(Math.floor(Math.random() * 8));
            state.policeDirections.push(Math.floor(Math.random() * 8));
            
            updatePolicePositions();
        }
        
        // Update player car position on screen
        function updatePlayerPosition() {
            const centerOffset = (config.gridSize % 2 === 0) ? config.cellSize / 2 : 0;
            const px = state.playerPosition.x * config.cellSize + centerOffset;
            const py = state.playerPosition.y * config.cellSize + centerOffset;
            
            playerCar.style.left = `${px - 6}px`;
            playerCar.style.top = `${py - 10}px`;
            playerCar.style.transform = `rotate(${state.playerDirection * 90}deg)`;
        }
        
        // Update police car positions on screen
        function updatePolicePositions() {
            const centerOffset = (config.gridSize % 2 === 0) ? config.cellSize / 2 : 0;
            
            for (let i = 0; i < state.policePositions.length; i++) {
                const policeCar = i === 0 ? policeCar1 : policeCar2;
                const pos = state.policePositions[i];
                const dir = state.policeDirections[i];
                
                const px = pos.x * config.cellSize + centerOffset;
                const py = pos.y * config.cellSize + centerOffset;
                
                policeCar.style.left = `${px - 6}px`;
                policeCar.style.top = `${py - 10}px`;
                policeCar.style.transform = `rotate(${dir * 45}deg)`;
            }
        }
        
        // Roll the dice to determine movement
        function rollDice() {
            if (state.gameOver) return;
            
            state.diceValue = Math.floor(Math.random() * 6) + 1;
            diceElement.textContent = state.diceValue;
            
            // Calculate path to next intersection
            state.currentPath = calculatePath(state.playerPosition.x, state.playerPosition.y, state.playerDirection);
            
            // Check if first segment has red light
            if (state.currentPath.length > 0) {
                const firstSegment = state.currentPath[0];
                const lightKey = `${firstSegment.fromX},${firstSegment.fromY},${firstSegment.direction}`;
                if (state.trafficLights[lightKey] === 'red') {
                    showMessage("Red light! You must stop here.");
                    state.movesRemaining = 0;
                    state.currentPath = [];
                    endTurn();
                    return;
                }
            }
            
            state.movesRemaining = state.diceValue;
            rollBtn.disabled = true;
            
            // If we have moves, start moving
            if (state.movesRemaining > 0) {
                movePlayerAlongPath();
            } else {
                endTurn();
            }
        }
        
        // Calculate path from current position in current direction
        function calculatePath(startX, startY, startDir) {
            const path = [];
            let x = startX;
            let y = startY;
            let dir = startDir;
            
            // Convert direction to dx/dy (simplified for grid)
            let dx = 0, dy = 0;
            if (dir === 0) dx = 1; // right
            else if (dir === 1) dy = 1; // down
            else if (dir === 2) dx = -1; // left
            else if (dir === 3) dy = -1; // up
            else if (dir === 4) { dx = 1; dy = -1; } // up-right
            else if (dir === 5) { dx = 1; dy = 1; } // down-right
            else if (dir === 6) { dx = -1; dy = 1; } // down-left
            else if (dir === 7) { dx = -1; dy = -1; } // up-left
            
            // Follow the road until next intersection or edge of map
            while (true) {
                const nextX = x + dx;
                const nextY = y + dy;
                
                // Check if next position is valid (on the grid)
                if (nextX < 0 || nextX >= config.gridSize || nextY < 0 || nextY >= config.gridSize) {
                    break;
                }
                
                // Add segment to path
                path.push({
                    fromX: x,
                    fromY: y,
                    toX: nextX,
                    toY: nextY,
                    direction: dir
                });
                
                // Move to next position
                x = nextX;
                y = nextY;
                
                // Check if we've reached an intersection (always true in grid)
                break;
            }
            
            return path;
        }
        
        // Move player along the current path
        function movePlayerAlongPath() {
            if (state.currentPath.length === 0 || state.movesRemaining <= 0) {
                endTurn();
                return;
            }
            
            const segment = state.currentPath.shift();
            state.playerPosition.x = segment.toX;
            state.playerPosition.y = segment.toY;
            state.playerDirection = segment.direction;
            
            updatePlayerPosition();
            state.movesRemaining--;
            
            // Check if we've reached an intersection (end of path)
            if (state.currentPath.length === 0) {
                // Show direction buttons
                directionButtons.style.display = 'flex';
                return;
            }
            
            // Check for red light on next segment
            const nextSegment = state.currentPath[0];
            const lightKey = `${nextSegment.fromX},${nextSegment.fromY},${nextSegment.direction}`;
            if (state.trafficLights[lightKey] === 'red') {
                showMessage("Red light ahead! Stopping.");
                state.movesRemaining = 0;
                state.currentPath = [];
                directionButtons.style.display = 'flex';
                return;
            }
            
            // Continue moving
            setTimeout(movePlayerAlongPath, 300);
        }
        
        // Choose direction at intersection
        function chooseDirection(turn) {
            directionButtons.style.display = 'none';
            
            // Calculate new direction (0-7)
            state.playerDirection = (state.playerDirection + turn + 8) % 8;
            
            // Update player display
            updatePlayerPosition();
            
            // If we have moves left, continue moving
            if (state.movesRemaining > 0) {
                // Calculate new path
                state.currentPath = calculatePath(state.playerPosition.x, state.playerPosition.y, state.playerDirection);
                
                // Check for red light
                if (state.currentPath.length > 0) {
                    const firstSegment = state.currentPath[0];
                    const lightKey = `${firstSegment.fromX},${firstSegment.fromY},${firstSegment.direction}`;
                    if (state.trafficLights[lightKey] === 'red') {
                        showMessage("Red light! You must stop here.");
                        state.movesRemaining = 0;
                        state.currentPath = [];
                        endTurn();
                        return;
                    }
                }
                
                if (state.movesRemaining > 0 && state.currentPath.length > 0) {
                    movePlayerAlongPath();
                } else {
                    endTurn();
                }
            } else {
                endTurn();
            }
        }
        
        // End the current turn
        function endTurn() {
            state.turn++;
            updateUI();
            
            // Move police cars
            movePolice();
            
            // Check if police caught player
            checkPoliceCatch();
            
            // Check if game over (max turns reached)
            if (state.turn >= config.maxTurns) {
                state.gameOver = true;
                showMessage("You escaped the police! Game over.");
                rollBtn.disabled = true;
                return;
            }
            
            // Enable roll button for next turn
            rollBtn.disabled = false;
            diceElement.textContent = "?";
        }
        
        // Move police cars toward player
        function movePolice() {
            for (let i = 0; i < state.policePositions.length; i++) {
                const police = state.policePositions[i];
                const player = state.playerPosition;
                
                // Simple AI: move toward player
                const dx = player.x - police.x;
                const dy = player.y - police.y;
                
                // Prefer cardinal directions
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = dx > 0 ? 1 : -1;
                } else {
                    moveY = dy > 0 ? 1 : -1;
                }
                
                // If stuck, try diagonal
                const newX = police.x + moveX;
                const newY = police.y + moveY;
                if (newX < 0 || newX >= config.gridSize || newY < 0 || newY >= config.gridSize) {
                    if (dx !== 0 && dy !== 0) {
                        moveX = dx > 0 ? 1 : -1;
                        moveY = dy > 0 ? 1 : -1;
                    }
                }
                
                // Update position
                police.x += moveX;
                police.y += moveY;
                
                // Keep within bounds
                police.x = Math.max(0, Math.min(config.gridSize - 1, police.x));
                police.y = Math.max(0, Math.min(config.gridSize - 1, police.y));
                
                // Update direction
                if (moveX > 0 && moveY === 0) state.policeDirections[i] = 0; // right
                else if (moveX === 0 && moveY > 0) state.policeDirections[i] = 1; // down
                else if (moveX < 0 && moveY === 0) state.policeDirections[i] = 2; // left
                else if (moveX === 0 && moveY < 0) state.policeDirections[i] = 3; // up
                else if (moveX > 0 && moveY < 0) state.policeDirections[i] = 4; // up-right
                else if (moveX > 0 && moveY > 0) state.policeDirections[i] = 5; // down-right
                else if (moveX < 0 && moveY > 0) state.policeDirections[i] = 6; // down-left
                else if (moveX < 0 && moveY < 0) state.policeDirections[i] = 7; // up-left
            }
            
            updatePolicePositions();
        }
        
        // Check if police caught the player
        function checkPoliceCatch() {
            for (const police of state.policePositions) {
                const dx = police.x - state.playerPosition.x;
                const dy = police.y - state.playerPosition.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance <= config.policeCatchDistance) {
                    state.gameOver = true;
                    showMessage("The police caught you! Game over.");
                    rollBtn.disabled = true;
                    directionButtons.style.display = 'none';
                    break;
                }
            }
        }
        
        // Update UI elements
        function updateUI() {
            turnCounter.textContent = state.turn;
            
            // Calculate closest police distance
            let minDistance = Infinity;
            for (const police of state.policePositions) {
                const dx = police.x - state.playerPosition.x;
                const dy = police.y - state.playerPosition.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                minDistance = Math.min(minDistance, distance);
            }
            policeDistance.textContent = minDistance.toFixed(1);
        }
        
        // Show a message to the player
        function showMessage(msg) {
            messageElement.textContent = msg;
            setTimeout(() => {
                if (messageElement.textContent === msg) {
                    messageElement.textContent = '';
                }
            }, 3000);
        }
        
        // Utility function to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // Start the game
        initGame();
    </script>
</body>
</html>