<!DOCTYPE html>
<html>
<head>
    <title>Arena Fight RPG Pro</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* Добавленные стили для эффектов */
        .fire-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path fill="%23FF5722" d="M50 15c-10 25-15 40-25 55 20-15 35-5 45 5-15-10-25-25-25-40 15 15 25 30 25 45-5-20-15-35-20-50z"/></svg>');
            animation: flame 0.8s ease-out;
            pointer-events: none;
        }

        @keyframes flame {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .heal-effect {
            background: radial-gradient(circle, #00ff0080 0%, transparent 70%);
            animation: pulse 1s;
        }

        .shield-effect {
            border: 3px solid #2196F3;
            animation: shieldGlow 1.5s infinite;
        }

        @keyframes shieldGlow {
            0% { box-shadow: 0 0 10px #2196F3; }
            50% { box-shadow: 0 0 20px #2196F3; }
            100% { box-shadow: 0 0 10px #2196F3; }
        }

        .upgrade-card {
            background: #34495e;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .upgrade-card:hover {
            transform: translateY(-5px);
        }
    </style>
</head>
<body>
    <!-- Добавлено окно выбора улучшений -->
    <div id="upgrade-popup" class="menu" style="display: none;">
        <h2>Выберите улучшение</h2>
        <div id="upgrade-options"></div>
    </div>

    <script>
        // Расширенный класс способностей
        class Ability {
            constructor(name, type, power, cost, cooldown) {
                this.name = name;
                this.type = type;
                this.power = power;
                this.cost = cost;
                this.cooldown = cooldown;
                this.currentCooldown = 0;
            }

            canUse(energy) {
                return this.currentCooldown === 0 && energy >= this.cost;
            }

            use() {
                this.currentCooldown = this.cooldown;
            }

            updateCooldown() {
                if(this.currentCooldown > 0) this.currentCooldown--;
            }
        }

        // Обновлённый класс Fighter
        class Fighter {
            constructor(baseStats, elementId, gameState) {
                this.baseStats = baseStats;
                this.gameState = gameState;
                this.element = document.getElementById(elementId);
                this.abilities = [];
                this.energy = 100;
                this.reset();
            }

            reset() {
                this.stats = {
                    health: this.baseStats.health + (this.gameState.upgrades.health * 25),
                    minDmg: this.baseStats.minDmg + (this.gameState.upgrades.attack * 3),
                    maxDmg: this.baseStats.maxDmg + (this.gameState.upgrades.attack * 5),
                    critChance: this.gameState.upgrades.crit * 2,
                    dodgeChance: this.gameState.upgrades.dodge * 1.5
                };
                this.currentHealth = this.stats.health;
                this.energy = 100;
            }

            attack(target) {
                let damage = 0;
                const ability = this.selectAbility();
                
                if(ability && ability.canUse(this.energy)) {
                    damage = this.useAbility(ability, target);
                } else {
                    damage = this.basicAttack(target);
                }

                this.energy = Math.min(this.energy + 2, 100);
                return damage;
            }

            basicAttack(target) {
                let damage = Math.floor(Math.random() * 
                    (this.stats.maxDmg - this.stats.minDmg + 1)) + this.stats.minDmg;
                
                if(Math.random() * 100 < this.stats.critChance) {
                    damage *= 2;
                    this.showEffect('critical');
                }
                
                target.takeDamage(damage);
                return damage;
            }

            useAbility(ability, target) {
                this.energy -= ability.cost;
                ability.use();
                let damage = 0;

                switch(ability.type) {
                    case 'fire':
                        damage = ability.power + Math.floor(Math.random() * 10);
                        this.showEffect('fire', target.element);
                        break;
                    case 'heal':
                        this.heal(ability.power);
                        this.showEffect('heal');
                        return 0;
                    case 'shield':
                        this.addShield(ability.power);
                        this.showEffect('shield');
                        return 0;
                }

                target.takeDamage(damage);
                return damage;
            }

            showEffect(type, targetElement = this.element) {
                const effect = document.createElement('div');
                switch(type) {
                    case 'fire':
                        effect.className = 'fire-effect';
                        targetElement.appendChild(effect);
                        setTimeout(() => effect.remove(), 800);
                        break;
                    case 'heal':
                        this.element.classList.add('heal-effect');
                        setTimeout(() => this.element.classList.remove('heal-effect'), 1000);
                        break;
                    case 'shield':
                        this.element.classList.add('shield-effect');
                        setTimeout(() => this.element.classList.remove('shield-effect'), 3000);
                        break;
                    case 'critical':
                        const critText = document.createElement('div');
                        critText.textContent = 'CRIT!';
                        critText.style.color = '#FFD700';
                        critText.style.position = 'absolute';
                        critText.style.top = '-50px';
                        targetElement.appendChild(critText);
                        setTimeout(() => critText.remove(), 500);
                        break;
                }
            }

            selectAbility() {
                return this.abilities
                    .filter(a => a.canUse(this.energy))
                    .sort((a, b) => b.power - a.power)[0];
            }
        }

        // Обновлённый класс ArenaGame
        class ArenaGame {
            constructor() {
                this.gameState = new GameState();
                this.gameState.load();
                this.initAbilities();
                this.initTelegram();
                this.updateUI();
                this.initLevels();
                showMainMenu();
            }

            initAbilities() {
                this.abilities = {
                    fireStrike: new Ability('Огненный удар', 'fire', 40, 30, 3),
                    heal: new Ability('Лечение', 'heal', 50, 40, 4),
                    energyShield: new Ability('Щит', 'shield', 30, 25, 5)
                };
            }

            showUpgradeOptions() {
                const options = document.getElementById('upgrade-options');
                options.innerHTML = '';
                
                const upgrades = this.getRandomUpgrades(3);
                upgrades.forEach(upgrade => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `
                        <h3>${upgrade.title}</h3>
                        <p>${upgrade.description}</p>
                        <button onclick="game.applyUpgrade('${upgrade.type}')">Выбрать</button>
                    `;
                    options.appendChild(card);
                });

                document.getElementById('upgrade-popup').style.display = 'block';
            }

            getRandomUpgrades(count) {
                const possibleUpgrades = [
                    {
                        type: 'attack',
                        title: 'Улучшение атаки',
                        description: '+5 к минимальному и максимальному урону'
                    },
                    {
                        type: 'health',
                        title: 'Улучшение здоровья',
                        description: '+30 к максимальному здоровью'
                    },
                    {
                        type: 'crit',
                        title: 'Критический удар',
                        description: '+3% шанс критического удара'
                    },
                    {
                        type: 'dodge',
                        title: 'Уклонение',
                        description: '+2% шанс уклонения'
                    },
                    {
                        type: 'ability',
                        title: 'Новая способность',
                        description: 'Открывает новую боевую способность'
                    }
                ];

                return possibleUpgrades.sort(() => Math.random() - 0.5).slice(0, count);
            }

            applyUpgrade(type) {
                if(type === 'ability') {
                    const newAbility = Object.values(this.abilities)
                        .find(a => !this.gameState.playerAbilities.includes(a.name));
                    if(newAbility) this.gameState.playerAbilities.push(newAbility.name);
                } else {
                    this.gameState.upgrades[type]++;
                }
                
                this.gameState.save();
                this.updateUI();
                document.getElementById('upgrade-popup').style.display = 'none';
                showMainMenu();
            }
        }

        // Остальной код остаётся аналогичным предыдущей версии
        // с добавлением новых функций в соответствующие классы
    </script>
</body>
</html>