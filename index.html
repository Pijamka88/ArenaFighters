<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Sopwith</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #gameCanvas {
            background-color: #87CEEB;
            display: block;
            touch-action: none;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
        }
        #gameOverScreen {
            display: none;
        }
        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background-color: #45a049;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #healthDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="scoreDisplay">Score: 0</div>
    <div id="healthDisplay">Health: 100%</div>
    
    <div id="startScreen">
        <h1>CLASSIC SOPWITH</h1>
        <p>Fly your biplane and destroy enemy targets!</p>
        <p>Controls: Arrow keys to move, Space to shoot</p>
        <p>On mobile: Touch left/right to move, tap to shoot</p>
        <button id="startButton">START GAME</button>
    </div>
    
    <div id="gameOverScreen">
        <h1>GAME OVER</h1>
        <p id="finalScore">Your score: 0</p>
        <button id="restartButton">PLAY AGAIN</button>
    </div>

    <script>
        // Game constants
        const GRAVITY = 0.2;
        const THRUST = 0.3;
        const TURN_RATE = 3;
        const BULLET_SPEED = 7;
        const ENEMY_SPAWN_RATE = 150;
        const BUILDING_SPAWN_RATE = 300;
        const CLOUD_SPAWN_RATE = 200;
        const PLANE_WIDTH = 30;
        const PLANE_HEIGHT = 20;
        const BULLET_RADIUS = 3;
        const ENEMY_WIDTH = 25;
        const ENEMY_HEIGHT = 15;
        const BUILDING_WIDTH = 60;
        const BUILDING_HEIGHT_BASE = 30;
        const CLOUD_WIDTH = 50;
        const CLOUD_HEIGHT = 30;
        const GROUND_HEIGHT = 30;
        
        // Game variables
        let canvas, ctx;
        let gameWidth, gameHeight;
        let planeX, planeY, planeSpeedX, planeSpeedY, planeAngle;
        let bullets = [];
        let enemies = [];
        let buildings = [];
        let clouds = [];
        let score = 0;
        let health = 100;
        let gameRunning = false;
        let lastEnemySpawn = 0;
        let lastBuildingSpawn = 0;
        let lastCloudSpawn = 0;
        let keys = {};
        let touchStartX = 0;
        let touchEndX = 0;
        let touchActive = false;
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Event listeners for keyboard
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                // Prevent spacebar from scrolling page
                if (e.key === ' ') {
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Event listeners for touch controls
            canvas.addEventListener('touchstart', handleTouchStart, false);
            canvas.addEventListener('touchmove', handleTouchMove, false);
            canvas.addEventListener('touchend', handleTouchEnd, false);
            canvas.addEventListener('mousedown', handleMouseDown, false);
            
            // Button event listeners
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            
            // Start the game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Resize canvas to fit window
        function resizeCanvas() {
            gameWidth = window.innerWidth;
            gameHeight = window.innerHeight;
            
            canvas.width = gameWidth;
            canvas.height = gameHeight;
        }
        
        // Start a new game
        function startGame() {
            // Reset game state
            planeX = gameWidth / 4;
            planeY = gameHeight / 2;
            planeSpeedX = 0;
            planeSpeedY = 0;
            planeAngle = 0;
            bullets = [];
            enemies = [];
            buildings = [];
            clouds = [];
            score = 0;
            health = 100;
            lastEnemySpawn = 0;
            lastBuildingSpawn = 0;
            lastCloudSpawn = 0;
            
            // Update displays
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('healthDisplay').textContent = `Health: ${health}%`;
            
            // Hide start/game over screens
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            gameRunning = true;
        }
        
        // End the game
        function endGame() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `Your score: ${score}`;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        // Touch control handlers
        function handleTouchStart(e) {
            e.preventDefault();
            touchActive = true;
            touchStartX = e.touches[0].clientX;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (touchActive) {
                touchEndX = e.touches[0].clientX;
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            if (touchActive) {
                // Shoot if it was a tap (small movement)
                if (Math.abs(touchEndX - touchStartX) < 10) {
                    shootBullet();
                }
                touchActive = false;
            }
        }
        
        function handleMouseDown(e) {
            if (gameRunning) {
                shootBullet();
            }
        }
        
        // Game loop
        function gameLoop(timestamp) {
            if (gameRunning) {
                update(timestamp);
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Update game state
        function update(timestamp) {
            // Update plane controls
            if (keys['ArrowUp'] || touchActive && touchEndX < touchStartX - 20) {
                planeSpeedY = -THRUST;
                planeAngle = -15;
            } else if (keys['ArrowDown'] || touchActive && touchEndX > touchStartX + 20) {
                planeSpeedY = THRUST;
                planeAngle = 15;
            } else {
                planeSpeedY = 0;
                planeAngle = 0;
            }
            
            // Apply gravity
            planeSpeedY += GRAVITY;
            
            // Update plane position
            planeX += planeSpeedX;
            planeY += planeSpeedY;
            
            // Keep plane in bounds
            if (planeY < 0) {
                planeY = 0;
                planeSpeedY = 0;
            }
            
            if (planeY > gameHeight - GROUND_HEIGHT - PLANE_HEIGHT / 2) {
                planeY = gameHeight - GROUND_HEIGHT - PLANE_HEIGHT / 2;
                planeSpeedY = 0;
                health -= 5; // Crash damage
                if (health <= 0) {
                    health = 0;
                    endGame();
                }
                document.getElementById('healthDisplay').textContent = `Health: ${health}%`;
            }
            
            if (planeX < 0) {
                planeX = 0;
            }
            
            if (planeX > gameWidth) {
                planeX = gameWidth;
            }
            
            // Shoot with spacebar
            if (keys[' '] && bullets.length < 3) {
                shootBullet();
                keys[' '] = false; // Prevent rapid firing
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speedX;
                bullets[i].y += bullets[i].speedY;
                
                // Remove bullets that are off screen
                if (bullets[i].x > gameWidth || bullets[i].x < 0 || 
                    bullets[i].y > gameHeight || bullets[i].y < 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check bullet collisions with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(
                        bullets[i].x, bullets[i].y, BULLET_RADIUS,
                        enemies[j].x, enemies[j].y, ENEMY_WIDTH, ENEMY_HEIGHT
                    )) {
                        // Hit enemy
                        enemies.splice(j, 1);
                        bullets.splice(i, 1);
                        score += 10;
                        document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                        break;
                    }
                }
                
                // Check bullet collisions with buildings
                for (let j = buildings.length - 1; j >= 0; j--) {
                    if (checkCollision(
                        bullets[i].x, bullets[i].y, BULLET_RADIUS,
                        buildings[j].x, buildings[j].y, BUILDING_WIDTH, buildings[j].height
                    )) {
                        // Hit building
                        buildings[j].health -= 20;
                        bullets.splice(i, 1);
                        
                        if (buildings[j].health <= 0) {
                            buildings.splice(j, 1);
                            score += 20;
                            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                        }
                        break;
                    }
                }
            }
            
            // Spawn enemies
            if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE * (1000 + Math.random() * 1000)) {
                spawnEnemy();
                lastEnemySpawn = timestamp;
            }
            
            // Spawn buildings
            if (timestamp - lastBuildingSpawn > BUILDING_SPAWN_RATE * (1000 + Math.random() * 1000)) {
                spawnBuilding();
                lastBuildingSpawn = timestamp;
            }
            
            // Spawn clouds
            if (timestamp - lastCloudSpawn > CLOUD_SPAWN_RATE * (1000 + Math.random() * 1000)) {
                spawnCloud();
                lastCloudSpawn = timestamp;
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].x -= enemies[i].speed;
                
                // Remove enemies that are off screen
                if (enemies[i].x < -ENEMY_WIDTH) {
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Check enemy collisions with plane
                if (checkCollision(
                    planeX, planeY, PLANE_WIDTH / 2,
                    enemies[i].x, enemies[i].y, ENEMY_WIDTH, ENEMY_HEIGHT
                )) {
                    // Collision with enemy
                    enemies.splice(i, 1);
                    health -= 15;
                    if (health <= 0) {
                        health = 0;
                        endGame();
                    }
                    document.getElementById('healthDisplay').textContent = `Health: ${health}%`;
                }
            }
            
            // Update buildings
            for (let i = buildings.length - 1; i >= 0; i--) {
                // Check building collisions with plane
                if (checkCollision(
                    planeX, planeY, PLANE_WIDTH / 2,
                    buildings[i].x, buildings[i].y, BUILDING_WIDTH, buildings[i].height
                )) {
                    // Collision with building
                    health -= 25;
                    if (health <= 0) {
                        health = 0;
                        endGame();
                    }
                    document.getElementById('healthDisplay').textContent = `Health: ${health}%`;
                }
            }
            
            // Update clouds
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].x -= clouds[i].speed;
                
                // Remove clouds that are off screen
                if (clouds[i].x < -CLOUD_WIDTH) {
                    clouds.splice(i, 1);
                }
            }
        }
        
        // Draw everything
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            
            if (!gameRunning) {
                return;
            }
            
            // Draw sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#E0F7FF');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, gameWidth, gameHeight - GROUND_HEIGHT);
            
            // Draw ground
            ctx.fillStyle = '#5C4033';
            ctx.fillRect(0, gameHeight - GROUND_HEIGHT, gameWidth, GROUND_HEIGHT);
            
            // Draw clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (const cloud of clouds) {
                // Draw cloud as 3 circles
                ctx.beginPath();
                ctx.arc(cloud.x + 15, cloud.y + 10, 15, 0, Math.PI * 2);
                ctx.arc(cloud.x + 30, cloud.y + 15, 20, 0, Math.PI * 2);
                ctx.arc(cloud.x + 45, cloud.y + 10, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw buildings
            for (const building of buildings) {
                // Building base
                ctx.fillStyle = '#555';
                ctx.fillRect(building.x, building.y, BUILDING_WIDTH, building.height);
                
                // Windows
                ctx.fillStyle = '#FFD700';
                const windowWidth = 8;
                const windowHeight = 10;
                const windowMargin = 5;
                const windowsPerRow = Math.floor((BUILDING_WIDTH - windowMargin * 2) / (windowWidth + windowMargin));
                
                for (let row = 0; row < Math.floor(building.height / (windowHeight + windowMargin * 2)); row++) {
                    for (let col = 0; col < windowsPerRow; col++) {
                        if (Math.random() > 0.3) { // Random windows
                            ctx.fillRect(
                                building.x + windowMargin + col * (windowWidth + windowMargin),
                                building.y + windowMargin + row * (windowHeight + windowMargin),
                                windowWidth, windowHeight
                            );
                        }
                    }
                }
                
                // Health bar
                const healthBarWidth = BUILDING_WIDTH;
                const healthBarHeight = 5;
                ctx.fillStyle = 'red';
                ctx.fillRect(building.x, building.y - healthBarHeight - 2, healthBarWidth, healthBarHeight);
                ctx.fillStyle = 'green';
                ctx.fillRect(building.x, building.y - healthBarHeight - 2, healthBarWidth * (building.health / 100), healthBarHeight);
            }
            
            // Draw enemies
            ctx.fillStyle = '#C00';
            for (const enemy of enemies) {
                // Enemy plane (simple triangle)
                ctx.save();
                ctx.translate(enemy.x + ENEMY_WIDTH / 2, enemy.y + ENEMY_HEIGHT / 2);
                ctx.rotate(Math.PI); // Point left
                
                ctx.beginPath();
                ctx.moveTo(ENEMY_WIDTH / 2, 0);
                ctx.lineTo(-ENEMY_WIDTH / 2, -ENEMY_HEIGHT / 2);
                ctx.lineTo(-ENEMY_WIDTH / 2, ENEMY_HEIGHT / 2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // Draw bullets
            ctx.fillStyle = '#FF0';
            for (const bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, BULLET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw player plane
            ctx.save();
            ctx.translate(planeX, planeY);
            ctx.rotate(planeAngle * Math.PI / 180);
            
            // Plane body (rectangle)
            ctx.fillStyle = '#963';
            ctx.fillRect(-PLANE_WIDTH / 2, -PLANE_HEIGHT / 2, PLANE_WIDTH, PLANE_HEIGHT);
            
            // Plane wings (cross)
            ctx.strokeStyle = '#963';
            ctx.lineWidth = 3;
            ctx.beginPath();
            // Horizontal wing
            ctx.moveTo(-PLANE_WIDTH / 2, 0);
            ctx.lineTo(PLANE_WIDTH / 2, 0);
            // Vertical tail
            ctx.moveTo(0, -PLANE_HEIGHT / 4);
            ctx.lineTo(0, PLANE_HEIGHT / 2);
            ctx.stroke();
            
            // Propeller
            ctx.fillStyle = '#333';
            ctx.fillRect(PLANE_WIDTH / 2 - 5, -3, 5, 6);
            
            ctx.restore();
        }
        
        // Shoot a bullet
        function shootBullet() {
            if (!gameRunning) return;
            
            bullets.push({
                x: planeX + PLANE_WIDTH / 2 * Math.cos(planeAngle * Math.PI / 180),
                y: planeY + PLANE_WIDTH / 2 * Math.sin(planeAngle * Math.PI / 180),
                speedX: BULLET_SPEED,
                speedY: planeSpeedY * 0.5
            });
        }
        
        // Spawn an enemy
        function spawnEnemy() {
            enemies.push({
                x: gameWidth,
                y: Math.random() * (gameHeight - GROUND_HEIGHT - ENEMY_HEIGHT),
                speed: 2 + Math.random() * 2
            });
        }
        
        // Spawn a building
        function spawnBuilding() {
            const height = BUILDING_HEIGHT_BASE + Math.random() * 100;
            buildings.push({
                x: gameWidth,
                y: gameHeight - GROUND_HEIGHT - height,
                height: height,
                health: 100
            });
        }
        
        // Spawn a cloud
        function spawnCloud() {
            clouds.push({
                x: gameWidth,
                y: Math.random() * (gameHeight - GROUND_HEIGHT - 100),
                speed: 0.5 + Math.random()
            });
        }
        
        // Check collision between two objects
        function checkCollision(x1, y1, radius1, x2, y2, width2, height2) {
            // Circle (bullet) vs rectangle (enemy/building) collision
            const closestX = Math.max(x2, Math.min(x1, x2 + width2));
            const closestY = Math.max(y2, Math.min(y1, y2 + height2));
            
            const distanceX = x1 - closestX;
            const distanceY = y1 - closestY;
            
            return (distanceX * distanceX + distanceY * distanceY) < (radius1 * radius1);
        }
        
        // Start the game when the page loads
        window.onload = init;
    </script>
</body>
</html>